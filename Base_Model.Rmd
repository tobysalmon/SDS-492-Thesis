---
title: "Base Nowcast Model"
output: html_document
date: "2026-02-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(rjags)
library(tidyverse)
library(coda)
library(tidycensus)
```

```{r}
#census_api_key("81e4817f989c60bf268764565acf7fb7fbe0e2cf", install = TRUE)
```

## Load in the Data
```{r load_data}
data <- read_csv("https://raw.githubusercontent.com/PopHIVE/Ingest/main/data/respnet/standard/data.csv.gz")

# filtering the data to New York state and using "total" as the age demographic
# New York State FIPS code is 36

data <- data %>%
  filter(geography == "36", age == "Total")

ny_pop <- get_estimates(
  geography = "state",
  state = "36",
  product = "population",
  year = 2024,  # Most recent available
  time_series = TRUE
) |>
  filter(variable == "POPESTIMATE", year %in% c(2023,2024)) %>%
  arrange(year) %>%
  pull(value)

ny_pop_estimates <- tibble(
  year = 2018:2026,
  population = c(
    # New York State DOH estimates
    19542209, #2018
    19453561, #2019
    19336776, #2020
    19857492, #2021
    19673200, #2022
    
    # from census API
    ny_pop[1],   #2023 
    ny_pop[2],  #2024
    
    # From census website -- not included in the API
    20002427, #2025
    
    # using 2025 estimate for 2026
    20002427 #2026
  )
)

```

## Merging Population Estimates with Data
```{r population_merge}
data_with_pop <- data %>%
  mutate(year = year(time)) %>%
  left_join(ny_pop_estimates, by = "year")

data_with_pop <- data_with_pop %>%
  mutate(
    covid_count = round(rate_covid * population / 100000),
    flu_count = round(rate_flu * population / 100000),
    rsv_count = round(rate_rsv * population / 100000)
  )
```

## JAGS Model with Sliding Window Evaluation
 
The model has two components:
1. **Training period (1:t_train)**: Learn parameters from observed data
2. **Evaluation period (t_train+1:tmax)**: Predict held-out observations
 
```{r jags-model}
model_string <- "
model {
  # TRAINING PERIOD: Likelihood for observed data
  # Flu and RSV use full time series
  for(i in 1:t_train) {
    flu[i] ~ dpois(lambda1[i])
    rsv[i] ~ dpois(lambda2[i])
  }
  
  # COVID only from t_start_covid onwards
  for(i in t_start_covid:t_train) {
    covid[i] ~ dpois(lambda3[i])
  }

  # EVALUATION PERIOD: Generate predictions
  for(i in (t_train+1):tmax) {
    flu_pred[i] ~ dpois(lambda1[i])
    rsv_pred[i] ~ dpois(lambda2[i])
    covid_pred[i] ~ dpois(lambda3[i])
  }

  # Log-linear model for rates (all time points)
  for(i in 1:tmax) {
    lambda1[i] <- exp(phi[i,1])
    lambda2[i] <- exp(phi[i,2])
    lambda3[i] <- exp(phi[i,3])
  }

  # Priors - AR(1) process for each disease
  for(k in 1:3) {
    mu0[k] ~ dnorm(0, 1e-4)
    prec.phi[k] ~ dgamma(0.01, 0.01)
    rho1[k] ~ dunif(0, 1)

    phi[1,k] ~ dnorm(mu0[k], prec.phi[k] / (1 - pow(rho1[k], 2)))

    for(i in 2:tmax) {
      phi[i,k] ~ dnorm(mu0[k] + rho1[k] * (phi[i-1,k] - mu0[k]), prec.phi[k])
    }
  }
}
"

writeLines(model_string, "base_model.jags")

```
 
## Prepare JAGS Data
 
```{r jags-data}
# Number of weeks to hold out for evaluation
n_holdout <- 1  
 
# Define training and total periods
tmax <- nrow(data_with_pop)
t_train <- tmax - n_holdout

t_start_covid <- which(data_with_pop$covid_count > 0)[1]

# Prepare data list for JAGS
# Only pass training data for flu/rsv/covid
jags_data <- list(
  flu = data_with_pop$flu_count[1:t_train],
  rsv = data_with_pop$rsv_count[1:t_train],
  covid = data_with_pop$covid_count[1:t_train],
  t_train = t_train,
  tmax = tmax,
  t_start_covid = t_start_covid
)
 
# Store the held-out actuals for comparison
actuals_holdout <- data_with_pop %>%
  tail(n_holdout) %>%
  select(time, flu_count, rsv_count, covid_count)
 
cat("\nHeld-out actual values:\n")
print(actuals_holdout)
```
 
## Run JAGS Model
 
```{r run-jags, message=FALSE, warning=FALSE}
# Parameters to monitor
# Include flu_pred, rsv_pred, covid_pred for the evaluation period
params <- c("mu0", "rho1", "prec.phi", "lambda1", "lambda2", "lambda3",
            "flu_pred", "rsv_pred", "covid_pred")
 
# Initialize the model
jags_model <- jags.model(
  file = "base_model.jags",
  data = jags_data,
  n.chains = 3,
  n.adapt = 1000,
  inits = list(
    list(".RNG.seed" = 123, ".RNG.name" = "base::Wichmann-Hill"),
    list(".RNG.seed" = 456, ".RNG.name" = "base::Wichmann-Hill"),
    list(".RNG.seed" = 789, ".RNG.name" = "base::Wichmann-Hill")
  )
)
 
# Burn-in
update(jags_model, n.iter = 10000)  

samples <- coda.samples(
  model = jags_model,
  variable.names = params,
  n.iter = 20000,  
  thin = 10      
)
```
 
## Model Diagnostics
 
```{r diagnostics}
# Summary of key parameters
summary(samples[, c("mu0[1]", "mu0[2]", "mu0[3]",
                    "rho1[1]", "rho1[2]", "rho1[3]")])
 
# Trace plots for AR(1) parameters
plot(samples[, c("rho1[1]", "rho1[2]", "rho1[3]")])
 
# Gelman-Rubin diagnostic (should be close to 1)
gelman.diag(samples[, c("mu0[1]", "mu0[2]", "mu0[3]",
                        "rho1[1]", "rho1[2]", "rho1[3]")])
```
 
 
## Extract Predictions and Evaluate
 
```{r extract-predictions, warning=FALSE}
# Combine chains
samples_combined <- do.call(rbind, samples)
 
# Extract predictions for held-out weeks
eval_results <- tibble(
  week = 1:n_holdout,
  time = actuals_holdout$time,
 
  # Actual values
  actual_flu = actuals_holdout$flu_count,
  actual_rsv = actuals_holdout$rsv_count,
  actual_covid = actuals_holdout$covid_count
)
 
# Add predictions for each held-out week
for (h in 1:n_holdout) {
  idx <- t_train + h
 
  # Extract posterior samples for predictions
  flu_samples <- samples_combined[, paste0("flu_pred[", idx, "]")]
  rsv_samples <- samples_combined[, paste0("rsv_pred[", idx, "]")]
  covid_samples <- samples_combined[, paste0("covid_pred[", idx, "]")]
 
  # Calculate summary statistics
  eval_results$pred_flu[h] <- mean(flu_samples)
  eval_results$pred_flu_lower[h] <- quantile(flu_samples, 0.025)
  eval_results$pred_flu_upper[h] <- quantile(flu_samples, 0.975)
 
  eval_results$pred_rsv[h] <- mean(rsv_samples)
  eval_results$pred_rsv_lower[h] <- quantile(rsv_samples, 0.025)
  eval_results$pred_rsv_upper[h] <- quantile(rsv_samples, 0.975)
 
  eval_results$pred_covid[h] <- mean(covid_samples)
  eval_results$pred_covid_lower[h] <- quantile(covid_samples, 0.025)
  eval_results$pred_covid_upper[h] <- quantile(covid_samples, 0.975)
}
 
# Calculate errors and coverage
eval_results <- eval_results %>%
  mutate(
    error_flu = actual_flu - pred_flu,
    error_rsv = actual_rsv - pred_rsv,
    error_covid = actual_covid - pred_covid,
 
    covered_flu = actual_flu >= pred_flu_lower & actual_flu <= pred_flu_upper,
    covered_rsv = actual_rsv >= pred_rsv_lower & actual_rsv <= pred_rsv_upper,
    covered_covid = actual_covid >= pred_covid_lower & actual_covid <= pred_covid_upper
  )
 
cat("=== Prediction Results ===\n")
print(eval_results %>% select(time, actual_flu, pred_flu, error_flu, covered_flu))
print(eval_results %>% select(time, actual_rsv, pred_rsv, error_rsv, covered_rsv))
print(eval_results %>% select(time, actual_covid, pred_covid, error_covid, covered_covid))
```
 
## Evaluation Metrics
 
```{r evaluation-metrics}
# Calculate summary metrics
metrics <- tibble(
  disease = c("Flu", "RSV", "COVID"),
  MAE = c(
    mean(abs(eval_results$error_flu)),
    mean(abs(eval_results$error_rsv)),
    mean(abs(eval_results$error_covid))
  ),
  RMSE = c(
    sqrt(mean(eval_results$error_flu^2)),
    sqrt(mean(eval_results$error_rsv^2)),
    sqrt(mean(eval_results$error_covid^2))
  ),
  Coverage = c(
    mean(eval_results$covered_flu),
    mean(eval_results$covered_rsv),
    mean(eval_results$covered_covid)
  )
)
 
cat("=== Evaluation Metrics ===\n")
cat("MAE = Mean Absolute Error\n")
cat("RMSE = Root Mean Squared Error\n")
cat("Coverage = Proportion of actuals within 95% CI (target: 0.95)\n\n")
print(metrics)
```
 
## Extract Fitted Values for Training Period
 
```{r fitted-values}
# Extract lambda (fitted rates) for training period
lambda1_cols <- grep("^lambda1\\[", colnames(samples_combined))
lambda2_cols <- grep("^lambda2\\[", colnames(samples_combined))
lambda3_cols <- grep("^lambda3\\[", colnames(samples_combined))
 
# Posterior means (all time points)
fitted_flu <- colMeans(samples_combined[, lambda1_cols])
fitted_rsv <- colMeans(samples_combined[, lambda2_cols])
fitted_covid <- colMeans(samples_combined[, lambda3_cols])
 
# Posterior credible intervals (95%)
fitted_flu_lower <- apply(samples_combined[, lambda1_cols], 2, quantile, 0.025)
fitted_flu_upper <- apply(samples_combined[, lambda1_cols], 2, quantile, 0.975)
 
fitted_rsv_lower <- apply(samples_combined[, lambda2_cols], 2, quantile, 0.025)
fitted_rsv_upper <- apply(samples_combined[, lambda2_cols], 2, quantile, 0.975)
 
fitted_covid_lower <- apply(samples_combined[, lambda3_cols], 2, quantile, 0.025)
fitted_covid_upper <- apply(samples_combined[, lambda3_cols], 2, quantile, 0.975)
 
# Create results dataframe for full time series
results <- data_with_pop %>%
  mutate(
    fitted_flu = fitted_flu,
    fitted_flu_lower = fitted_flu_lower,
    fitted_flu_upper = fitted_flu_upper,
    fitted_rsv = fitted_rsv,
    fitted_rsv_lower = fitted_rsv_lower,
    fitted_rsv_upper = fitted_rsv_upper,
    fitted_covid = fitted_covid,
    fitted_covid_lower = fitted_covid_lower,
    fitted_covid_upper = fitted_covid_upper,
    period = ifelse(row_number() <= t_train, "Training", "Evaluation")
  )
```
 
## Visualization
 
```{r plots, fig.width=10, fig.height=10}
library(patchwork)
 
# Flu
p1 <- ggplot(results, aes(x = time)) +
  geom_ribbon(aes(ymin = fitted_flu_lower, ymax = fitted_flu_upper),
              fill = "blue", alpha = 0.2) +
  geom_line(aes(y = fitted_flu), color = "blue", linewidth = 1) +
  geom_point(aes(y = flu_count, shape = period), alpha = 0.7, size = 2) +
  geom_vline(xintercept = results$time[t_train], linetype = "dashed", color = "gray40") +
  scale_shape_manual(values = c("Training" = 16, "Evaluation" = 17)) +
  labs(title = "Flu: Observed vs Fitted",
       subtitle = "Dashed line = train/eval split, Triangle = held-out",
       y = "Count", x = "Time") +
  theme_minimal()
 
# RSV
p2 <- ggplot(results, aes(x = time)) +
  geom_ribbon(aes(ymin = fitted_rsv_lower, ymax = fitted_rsv_upper),
              fill = "green", alpha = 0.2) +
  geom_line(aes(y = fitted_rsv), color = "darkgreen", linewidth = 1) +
  geom_point(aes(y = rsv_count, shape = period), alpha = 0.7, size = 2) +
  geom_vline(xintercept = results$time[t_train], linetype = "dashed", color = "gray40") +
  scale_shape_manual(values = c("Training" = 16, "Evaluation" = 17)) +
  labs(title = "RSV: Observed vs Fitted", y = "Count", x = "Time") +
  theme_minimal()
 
# COVID
p3 <- ggplot(results, aes(x = time)) +
  geom_ribbon(aes(ymin = fitted_covid_lower, ymax = fitted_covid_upper),
              fill = "red", alpha = 0.2) +
  geom_line(aes(y = fitted_covid), color = "darkred", linewidth = 1) +
  geom_point(aes(y = covid_count, shape = period), alpha = 0.7, size = 2) +
  geom_vline(xintercept = results$time[t_train], linetype = "dashed", color = "gray40") +
  scale_shape_manual(values = c("Training" = 16, "Evaluation" = 17)) +
  labs(title = "COVID: Observed vs Fitted", y = "Count", x = "Time") +
  theme_minimal()
 
p1 / p2 / p3
```
 
## Model Summary
 
```{r summary}
# AR(1) parameters for each disease
cat("=== AR(1) Autocorrelation Parameters (rho) ===\n")
cat("Flu:  ", round(mean(samples_combined[, "rho1[1]"]), 3), "\n")
cat("RSV:  ", round(mean(samples_combined[, "rho1[2]"]), 3), "\n")
cat("COVID:", round(mean(samples_combined[, "rho1[3]"]), 3), "\n")
 
# Mean levels
cat("\n=== Mean Log-Rate Parameters (mu0) ===\n")
cat("Flu:  ", round(mean(samples_combined[, "mu0[1]"]), 3), "\n")
cat("RSV:  ", round(mean(samples_combined[, "mu0[2]"]), 3), "\n")
cat("COVID:", round(mean(samples_combined[, "mu0[3]"]), 3), "\n")
 
cat("\n=== Evaluation Summary ===\n")
cat("Held out last", n_holdout, "weeks for evaluation\n")
print(metrics)
```



